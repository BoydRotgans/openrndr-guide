# Custom rendering #

A simple custom rendering sketch will look like this. In this sketch we draw a single rectangle, that is formed by drawing two triangles.

```java

VBOLayout layout = new VBOLayout().color(4).position(2);
Shader shader;
VBO vbo;

public void setup() {
    shader = Shader.fromUrls("cp:myshader.vert", "cp:myshader.frag");
    ByteBuffer bb = ByteBuffer.allocateDirect(layout.size() * 6);
    BufferWriter bw = new BufferWriter(bb);
    bw.write(Color.WHITE).write(new Vector2(0, 0));
    bw.write(Color.WHITE).write(new Vector2(0, 0));
    bw.write(Color.WHITE).write(new Vector2(0, 0));
    bw.write(Color.WHITE).write(new Vector2(0, 0));
    bw.write(Color.WHITE).write(new Vector2(0, 0));
    bw.write(Color.WHITE).write(new Vector2(0, 0));

    vbo = VBO.createStatic(bb, bb.capacity);
}

public void draw() {
    background(Color.BLACK);
    shader.begin();
    shader.setUniform("modelViewMatrix", drawer.modelView().transpose());
    shader.setUniform("projectionMatrix", drawer.projection().transpose());

    vbo.bind();
    VBODrawer.draw(gl3, vbo, vboLayout, shader, GL.GL_TRIANGLES, 6);
    vbo.unbind();
    shader.end();
}

```

Here we see a number of new OPENRNDR classes pop up, let's look at them one by one.

## Vertex Buffer Object (VBO)

A Vertex Buffer Object (VBO) is an OpenGL concept. A VBO holds vertex data and is the common term for a normal Buffer Object when it is used as a source for vertex array data. It is no different from any other buffer object, and a buffer object used for Transform Feedback or asynchronous pixel transfers can be used as source values for vertex arrays.

## VBOLayout

VBOLayout objects describe the vertices stored in a VBO.

## ByteBuffer

ByteBuffer is class found in Java's standard library. ByteBuffers allow you to write data into memory in a rather low level way.

## BufferWriter

BufferWriter is a helper class that makes writing things into ByteBuffers slightly nicer. BufferWriter can write RNDRs Vector2, Vector3, Vector3 and Color objects into a ByteBuffer.

## Shader, FragmentShader and VertexShader

Shaders are an OpenGL concept. A shader is a program that runs in the graphics pipeline and tells the computer how to render each pixel. These programs are called shaders because they're often used to control lighting and shading effects, but they can also handle other special effects. 

A Fragment Shader is the Shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value.

The fragment shader is the OpenGL pipeline stage after a primitive is rasterized. For each sample of the pixels covered by a primitive, a "fragment" is generated. Each fragment has a Window Space position, a few other values, and it contains all of the interpolated per-vertex output values from the last Vertex Processing stage.

The output of a fragment shader is a depth value, a possible stencil value (unmodified by the fragment shader), and zero or more color values to be potentially written to the buffers in the current framebuffers. Fragment shaders take a single fragment as input and produce a single fragment as output.

A Vertex Shader operates on individual vertices, one vertex at a time. The shader has no knowledge of the other vertices that make up the graphical primitive, and has no clue of what type of primitive the vertex belongs to. For each input vertex, this shader outputs a single vertex.

Each vertex has a set of user defined input attributes, for instance, position, normal vector, and texture coordinates. Vertex shaders also have access to uniform variables, which act as read-only global variables for all vertices in a draw call.

## VBODrawer

The VBODrawer is an OPENRNDR utility class that makes rendering from VBOs easy.

